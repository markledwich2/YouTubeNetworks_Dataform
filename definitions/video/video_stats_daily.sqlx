config {
    type:'incremental',
    uniqueKey: ['video_id', 'date'],
    tags: ['standard'],
    dependencies: ['video', 'channel_accepted', 'video_latest']
}

-- video_stats_daily spreads video views from our patchy as-at-time records into an estimate for views on each day
with delta as (
  select channel_id
       , video_id
       , max(updated) over (partition by video_id order by updated desc) as max_updated
       , views - coalesce(lag(views) over (partition by video_id order by updated), 0) as delta_views

       -- from date is the previous updated date, of if that is missing the upload_date
       -- sometimes the upload date is more recent than uploads (e.g. live stream scheduled in advance 21HQL59EsQY)
       , lag(updated) over (partition by video_id order by updated) as prev_date
       , min(upload_date) over (partition by video_id order by updated) as first_upload_date
       , updated as updated
       , updated::date as to_date
       , coalesce(prev_date, least(first_upload_date, updated), first_upload_date, updated)::date as from_date
       , greatest(1.0, datediff(days, from_date, to_date))::int as days --be careful. needs to match the v1 left join. e.g. if days rows match with delta, this should also be 2
       , views as total_views
  from video
  ${ when(incremental(), `qualify max_updated > (select max(updated) from ${self()})`) }
   -- where channel_id = 'UCupvZG-5ko_eiXAupbDfxWw'
  --where video_id = 'V7Qp4sg5fFg'
  
  -- the views spread takes into account previous records of videos. So we should always consider the full set of videos that have been updated
)
   -- change from a to/form record to one per day
   , days as (
  select
         date
  from date
  where date between (select min(from_date) from delta) and greatest((select max(to_date) from delta), current_date()::date))
   , vd0 as (
  select date,
         row_number() over (partition by video_id, updated order by date) as video_smear_no
       ,
         d.*
  from days -- query months and join to delta to spread across months sans updates
         inner join delta d on d.from_date = date or (d.from_date < date and date < d.to_date)
)
   -- ensure  record per day, and distribute views more realistically between updates
   , vd1 as (
  select date
       , video_id
       , min(video_smear_no) as video_smear_no
       , any_value(channel_id) as channel_id
       , sum(delta_views) as delta_views
       , max(total_views) as total_views
       , max(updated) as updated
       , min(from_date) as from_date
       , max(days) as days
       , min(first_upload_date) as first_upload_date
       , sum(1) as stats_recorded
  from vd0
  group by date, video_id -- possible to get multiple records for the same date because there are multiple overlapping ranges. group here so its clean downstream
)
   -- true-up any missing views to the first in the range. partition by updated to decay this particular this delta row
   , vd2 as (
  select video_id
       , date
       , channel_id
       , video_smear_no
    /*
views1: When our range is > 1 day and we should give a realistic distribution of views
to do this I took the average views for 2019 over age and created a formula using wolfram notebook
https://www.wolframcloud.com/obj/6f22519c-cb44-41bc-85e1-3f5e531b4e05
because the formula is an approximation we need to adjust as a second step to make it add up perfectly

ML 2020-05-18 this formula makes sense for the lst record, but for in-between smears, it lumps it too much to the first date dates:
*/
       , datediff(days, from_date::date, date)::int as range_age -- range age is the days old since from_date.
       , round(delta_views * iff(days > 1,
                                 iff(range_age < 30 and range_age >= 0, 1.0 / (pow(1.8 + range_age, 1.77)), null),
                                 1)) as views_decay -- up to 14 days of realistic decaying views

       , total_views
       , updated
       , days
       , delta_views
  from vd1
  where video_smear_no = 1 or abs(views_decay) >= 1 -- only include records where there are at least 1 view. its rounded, so tru-up logic still wrs
)
   -- the final result, re-select columns to remove any intermediate calculations
   , s as (
  select vd2.*
       , c.channel_title
       , c.main_channel_id
       , c.main_channel_title
       , c.ideology
       , c.media
       , v.video_title
       , v.upload_date
       , v.duration
       -- true-up on the first row with the difference from the total
       , iff(days > 1 and video_smear_no = 1,
          coalesce(views_decay, 0) + delta_views - (sum(coalesce(views_decay, 0)) over (partition by vd2.video_id, vd2.updated))
         , views_decay) as views
       --m.views * datediff(seconds, '00:00:00'::time, duration) / 60 / 60 as hours_watched
  from vd2
         left join channel_accepted c on c.channel_id = vd2.channel_id
         left join video_latest v on v.video_id = vd2.video_id
)
  -- check if there are any videos where the total views don't match the sum of all daily views
   , check_video_totals as (
  select *
  from (
         select video_id
              , sum(views) over (partition by video_id) as views_sum
              , last_value(total_views) over (partition by video_id order by date) as last_total_view
              , row_number() over (partition by video_id order by date desc) as age
         from s
         qualify age = 1
       )
  where last_total_view > 0 and views_sum <> last_total_view
--     and abs(1 - views_sum) > 20
--     and abs(1 - views_sum / last_total_view) > 0.01
)
   -- useful to tracking down where totals get out of sync
  , check_running_total as (
  select video_id, date, views, total_views, views_decay, range_age, video_smear_no, updated
       , sum(views) over (partition by video_id order by date rows between unbounded preceding and current row) as running_total
     from s
    order by video_id, date
)
select * from s
--select * from s order by date
--select * from vd2 order by date
--select * from check_video_totals
--select * from check_running_total
--select max(date), min(date) from days
--select * from delta
--select * from vd1 order by date
