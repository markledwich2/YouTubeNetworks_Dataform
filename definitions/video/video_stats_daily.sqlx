config {
    type:'incremental',
    uniqueKey: ['video_id', 'date'],
    tags: ['standard'],
    dependencies: ['video', 'channel_accepted', 'video_latest', 'date', 'video_watch_time']
}

-- video_stats_daily spreads video views from our patchy as-at-time records into an estimate for views on each day
with delta as (
  select channel_id
       , video_id
       , max(updated) over (partition by video_id order by updated desc) as max_updated
       , views-coalesce(lag(views) over (partition by video_id order by updated), 0) as delta_views

       -- from date is the previous updated date, of if that is missing the upload_date
       -- sometimes the upload date is more recent than uploads (e.g. live stream scheduled in advance 21HQL59EsQY)
       , lag(updated) over (partition by video_id order by updated) as prev_date
       , min(upload_date) over (partition by video_id order by updated) as first_upload_date
       , updated as updated
       , updated::date as to_date
       , coalesce(prev_date, least(first_upload_date, updated), first_upload_date, updated)::date as from_date
       , greatest(1.0, datediff(days, from_date, to_date))::int as days --be careful. needs to match the v1 left join. e.g. if days rows match with delta, this should also be 2
       , views as total_views
  from video v
  where exists(select channel_id from channel_accepted c where v.channel_id=c.channel_id)
  --  and video_id='V7Qp4sg5fFg'
  -- and channel_id = 'UCzQUP1qoWDoEbmsQxvdjxgQ'
  ${ when(incremental(), `qualify max_updated > (select max(updated) from ${self()})`) }
  -- the views spread takes into account previous records of videos. So we should always consider the full set of videos that have been updated
)
  -- change from a to/form record to one per day
   , days as (
  select date
  from date
  where date between (select min(from_date) from delta) and greatest((select max(to_date) from delta), current_date()::date))
   , vd0 as (
  select date
       , row_number() over (partition by video_id, updated order by date) as video_smear_no
       , d.*
  from days -- query months and join to delta to spread across months sans updates
         inner join delta d on d.from_date=date or (d.from_date<date and date<d.to_date)
)
  -- ensure  record per day, and distribute views more realistically between updates
   , vd1 as (
  select date
       , video_id
       , min(video_smear_no) video_smear_no
       , any_value(channel_id) channel_id
       , sum(delta_views) delta_views
       , max(total_views) total_views
       , max(updated) updated
       , min(from_date) from_date
       , max(days) days
       , min(first_upload_date) first_upload_date
       , sum(1) stats_recorded
  from vd0
  group by date, video_id -- possible to get multiple records for the same date because there are multiple overlapping ranges. group here so its clean downstream
)
  -- true-up any missing views to the first in the range. partition by updated to decay this particular this delta row
   , vd2 as (
  select video_id
       , date
       , channel_id
       , video_smear_no
    /*
views1: When our range is > 1 day and we should give a realistic distribution of views
to do this I took the average views for 2019 over age and created a formula using wolfram notebook
https://www.wolframcloud.com/obj/6f22519c-cb44-41bc-85e1-3f5e531b4e05
because the formula is an approximation we need to adjust as a second step to make it add up perfectly

ML 2020-05-18 this formula makes sense for the lst record, but for in-between smears, it lumps it too much to the first date dates:
*/
       , datediff(days, from_date::date, date)::int as range_age -- range age is the days old since from_date.
       , round(delta_views*iff(days>1,
                               iff(range_age<30 and range_age>=0, 1.0/(pow(1.8+range_age, 1.77)), null),
                               1)) as views_decay -- up to 14 days of realistic decaying views

       , total_views
       , updated
       , days
       , delta_views
  from vd1
  where video_smear_no=1
     or abs(views_decay)>=1 -- only include records where there are at least 1 view. its rounded, so tru-up logic still wrs
)
  -- the final result, re-select columns to remove any intermediate calculations
   , s as (
  select vd2.video_id
       , vd2.channel_id
       , total_views
       , date
       , views_decay
       , delta_views
       , range_age
       , video_smear_no
       , vd2.updated
       -- true-up on the first row with the difference from the total
       , iff(days>1 and video_smear_no=1,
             coalesce(views_decay, 0)+delta_views-(sum(coalesce(views_decay, 0)) over (partition by vd2.video_id, vd2.updated))
    , views_decay) as views

  from vd2
)
  -- check if there are any videos where the total views don't match the sum of all daily views
   , check_video_totals as (
  select *
  from (
         select video_id
              , sum(views) over (partition by video_id) as views_sum
              , last_value(total_views) over (partition by video_id order by date) as last_total_view
              , row_number() over (partition by video_id order by date desc) as age
         from s
           qualify age=1
       )
  where last_total_view>0
    and views_sum<>last_total_view
)
  -- useful to tracking down where totals get out of sync
   , check_running_total as (
  select video_id
       , date
       , views
       , total_views
       , views_decay
       , range_age
       , video_smear_no
       , updated
       , sum(views) over (partition by video_id order by date rows between unbounded preceding and current row) as running_total
  from s
  order by video_id, date
)
, channel_duration as (
  select channel_id, avg(datediff(seconds, '0'::time, duration)) duration_seconds_avg from video_latest
  where duration is not null
  group by channel_id
)
select s.video_id
     , s.channel_id
     , date
     , s.views
     , s.updated
     , s.views*iff(v.duration is null, duration_seconds_avg, datediff(seconds, '0'::time, v.duration))/60/60*w.pct_watch as watch_hours
from s
       left join video_latest v on v.video_id=s.video_id
       left join video_watch_time w on datediff(seconds, '0'::time, duration) between w.from_s and w.to_s
    left join channel_duration d on d.channel_id = s.channel_id
where s.views > 0
