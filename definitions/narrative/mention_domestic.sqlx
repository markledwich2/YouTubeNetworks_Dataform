config {
  type: "table",
  dependencies: ['video_latest', 'caption'],
  description: `Mentions of popular q terms to classsify into sub-narratives`
}

js {
  const termSql = (col, terms) => {
    const termExpression = terms.filter((t) => Array.isArray(t))
    const termStrings = terms.filter((t) => !Array.isArray(t))

    const termESql = `array_compact(array_construct(${termExpression.map(([t, e]) => `iff(${e(col)}, '${t}', null)`)}))`
    const termSSql = `arrayuniq(arrayLower(arrayReplace(regexmatchall(${col}, ${`'\\b(${
      termStrings.map(t => t.replace(/'/g, "''").replace(' ', '\\s*')).join('|')
    })\\b'`.replace(/\\/g, '\\\\')}, 'i'), '\\\\s+', '', '')))`

    return `array_cat(${termESql}, ${termSSql})`
  }

  function select_context(terms, table, col, part, expressions) {
    part = part || col
    var allExpressions = [
      'video_id', 
      `${termSql(col, terms)} matches`,
      `${col} context`,
      `'${part}' part`
      ].concat(expressions ? expressions : [])
    return `select ${allExpressions.join(',\n  ')} from ${table} where matches is not null and array_size(matches)>0`
  }

  function mentions(terms, video_table) {
    video_table = video_table || video_latest
    return `
(
  with cap as (
    select s.video_id, s.caption, offset_seconds from caption s
    join ${video_table} v on v.video_id = s.video_id -- filter via vid table
  )
  ${select_context(terms, 'cap', 'caption', null, ['offset_seconds::int offset_seconds'])}
)
union all
${select_context(terms, video_table, 'video_title', 'title', ['null offset_seconds'])}
union all
${select_context(terms, video_table, 'description', null, ['null offset_seconds'])}
union all
(
  with kw as (
    select video_id, video_title, k.value::string keyword
    from video_latest, lateral flatten(input => keywords) k
  )
  ${select_context(terms, 'kw', 'keyword', null, ['null offset_seconds'])}
)
`
  }

  const arraySql = (arr) => `array_construct(${arr.map(a => `'${a.replace(/'/g, "\\'")}'`).join(', ')})`

  const dfr_terms = ['wwg1wga','the storm','great awakening','trust the plan','dark to light','future proves past',
    'disinformation is necessary','the military is the only way','we are the news',
    'save the children','pizzagate', 'pizza gate', 'Seth Rich',`there's q and there's anons`]


  // terms is an array of string terms. Or a tuple that returns a tuple in the form: [<name to use as the match>, a function returning a boolean extpression given the name of a column]

  const terms_extra = ['great reset', 'jfk', 'arizona recount', 'quo warranto', 'maricopa', 'qanon', 'q drop', 'Seth Rich', 
     'deep state', 'stop the steal', 'plandemic', 'cabal', 'puppet', 'soul family',
     'patriots?', 'prayer warriors', 'we the people', 'satanic ritual abuse', 'podesta', 'adrenochrome', 'pedophile ring', 
     'spirit cooking', 'child sex trafficking', 'mass arrests', ['trump reinstatement', c => `${c} like all ('%trump%', '%reinstate%') or ${c} like all ('%trump%', '%august%')`]]


}

with vids as (
  select video_id, video_title, v.description 
  from video_latest v join channel_latest c on c.channel_id = v.channel_id
  where upload_date > '2020-01-01' --and array_contains('QAnon'::variant, tags)
)
, mentions as (
  ${mentions(dfr_terms.concat(terms_extra), 'vids')}
)
select video_id, context, part, offset_seconds
  , arrayReplace(matches, 'patriots', '', 'patriot') matches
  , array_intersection(matches,${arraySql(dfr_terms.map(t => t.replace(/ /g, '')))}) matches_dfr
  
 from mentions

