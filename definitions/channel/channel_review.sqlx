config {
    type:'table',
    tags:["standard"],
    dependencies: []
}

with review as (
  select v:ChannelId::string as channel_id
       , v: Email::string as email
       , v:LR::string as lr
       , v:MainChannelId::string as main_channel_id
       , v:Notes::string as notes
       , v:Relevance::number/10 as relevance
       , v:Updated::timestamp_ntz as updated
       , v:SoftTags::array as tags
  from public.channel_review_stage
)
   
   , sam_reviews_raw as (
  select to_date(regexp_substr(metadata$filename, '_([0-9]+)_preds.txt', 1, 1, 'e'), 'YYYYMMDD')::timestamp_ntz as updated
       , $1::string as channel_id
       , $2::string as tag
       , $3::double as prob
  from @public.yt_data/import/recfluence_part_chan_all_soft_tags_20200727_preds.txt.gz (file_format => tsv)
)

   , sam_reviews as (
  select channel_id
       , array_agg(tag) as tags
       , any_value(lr) as lr
       , max(updated) as updated
  from (
         select channel_id
              , first_value(lr) over (partition by channel_id order by lr_prob desc) lr
              , case
                  when tag in ('MainstreamNews','MainstreamMedia') then 'Mainstream News'
                  else tag
           end as tag
              , prob
              , updated
         from (
                select channel_id
                     , iff(tag in ('L','C','R'), tag, null) as lr
                     , iff(lr is null, 0, prob) as lr_prob
                     , iff(tag in ('L','C','R','YouTube'), null, tag) as tag
                     , prob
                     , updated
                from sam_reviews_raw
              )
       )
  group by channel_id
)
 -- union human and algo reviews
   , all_reviews as (
  select *, decode(lr, 'L', -1, 'C', 0, 'R', 1, null) as lrnum
  from (
         select *
              , 0 as reviews_algo
         from review
         union all
         select channel_id
              , 'sam_algo' as email
              , lr
              , null as main_channel_id
              , 'predicted by sams algorythm' as notes
              , 1 as relevance
              , updated
              , tags
              , 1 as reviews_algo
         from sam_reviews
       )
)
   
   -- find the first date a tag has been introduced. Used when working out majority tags (ignore reviews pre-tag)
   , tag_stats as (
  select tag, date_trunc(minutes, min(updated)) as min_updated
  from (
         select updated, t.value::string as tag
         from review
            , table (flatten(tags)) t
       )
  group by tag
)
   
   -- humans sometimes update their reviews, use the latest
   , latest_review as (
  select *
       , count(*) over (partition by channel_id) as review_count
  from (
         select *
         from all_reviews
           qualify row_number() over (partition by email
             , channel_id order by updated desc)=1
       )
)
   
   -- flatten, o there is a row for each tag
   , tags_flat as (
  select channel_id
       , f.tag
       , email
       , updated
       , ts.min_updated
       , (select count(*) from latest_review r where r.channel_id=f.channel_id and r.updated>=ts.min_updated) as relevant_reviews
  from (
         -- flatten to row per tag & filter out stale reviews
         select channel_id
              , t.value::string as tag
              , r.email
              , updated
         from latest_review r
            , table (flatten(tags)) t
       ) f
         left join tag_stats ts on f.tag=ts.tag
)

  -- for each channel, calculate the final list of tags with a majority vote
   , tags_agg as (
  select channel_id
       , array_agg(tag) within group ( order by tag ) as tags
  from (
         select channel_id
              , tag
         from tags_flat
         group by channel_id, tag
         having count(*)>any_value(relevant_reviews)/2
       )
  group by channel_id
)
   
   -- group reviews by channel
   , r2 as (
  select channel_id
       , count(*) as reviews_all
       , sum(reviews_algo) as reviews_algo
       , array_agg(email) as reviewers
       , array_agg(object_construct(
      'email', email
    , 'lr', lr
    , 'main_channel_id', main_channel_id
    , 'notes', notes
    , 'relevance', relevance
    , 'tags', tags)) as reviews
       , decode(round(avg(lrnum)), -1, 'L', 0, 'C', 1, 'R') as lr
       , avg(relevance) as relevance
  from latest_review r
  group by 1
)
   
   -- latest channel (don't use the channel table so it can depend on this table)
   , cl as (
  select v:ChannelId::string as channel_id
       , v:ChannelTitle::string as channel_title
  from channel_stage
    qualify row_number() over (partition by channel_id order by v:Updated::timestamp_ntz desc)=1
)
   
   , s as (
  select c.channel_title
       , coalesce(t.tags, array_construct()) as tags
       , r2.*
  from r2
         left join cl c on r2.channel_id=c.channel_id
         left join tags_agg t on r2.channel_id=t.channel_id
)
select *
from s