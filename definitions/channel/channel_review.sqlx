config {
    type:'table',
    tags:["standard"],
    dependencies: []
}

with review as (
  select v:ChannelId::string as channel_id
       , v: Email::string as email
       , v:LR::string as lr
       , v:MainChannelId::string as main_channel_id
       , v:Notes::string as notes
       , v:Relevance::number/10 as relevance
       , v:Updated::timestamp_ntz as updated
       , v:SoftTags::array as tags
  from public.channel_review_stage
)

   , sam_reviews as (
  select channel_id
       , array_agg(tag) as tags
       , any_value(lr) as lr
       , max(updated) as updated
  from (
         select channel_id
              , first_value(lr) over (partition by channel_id order by lr_conf desc) lr
              , case
                  when tag in ('MainstreamNews','MainstreamMedia') then 'Mainstream News'
                  else tag
           end as tag
              , updated
         from (
                select channel_id
                     , iff(tag in ('L','C','R'), tag, null) as lr
                     , iff(lr is null, 0, confidence) as lr_conf
                     , iff(tag in ('L','C','R','YouTube'), null, tag) as tag
                     , confidence
                     , updated
                from channel_review_sam_raw
              )
         where confidence>=0.5
       )
  group by channel_id
)
   -- union human and algo reviews
   , all_reviews as (
  select *
       , decode(lr, 'L', -1, 'C', 0, 'R', 1, null) as lrnum
       , iff(reviews_algo=0, lrnum, null) as lrnum_human
       , iff(reviews_algo=0, relevance, null) as relevance_human
       , iff(reviews_algo=0, 1, 0.9) as weight -- on a tie, humans should win
  from (
         select *
              , 0 as reviews_algo
         from review
         union all
         select channel_id
              , 'sam_algo' as email
              , lr
              , null as main_channel_id
              , 'predicted by sams algorythm' as notes
              , 1 as relevance
              , updated
              , tags
              , 1 as reviews_algo
         from sam_reviews
       )
)

   -- find the first date a tag has been introduced. Used when working out majority tags (ignore reviews pre-tag)
   , tag_stats as (
  select tag, date_trunc(minutes, min(updated)) as min_updated
  from (
         select updated, t.value::string as tag
         from review
            , table (flatten(tags)) t
       )
  group by tag
)

   -- humans sometimes update their reviews, use the latest
   , latest_review as (
  select *
       , count(*) over (partition by channel_id) as review_count
  from (
         select *
         from all_reviews
           qualify row_number() over (partition by email
             , channel_id order by updated desc)=1
       )
)

   -- flatten, o there is a row for each tag
   , tags_flat as (
  select channel_id
       , f.tag
       , email
       , updated
       , ts.min_updated
       , reviews_algo
       , weight
       , (select sum(weight) from latest_review r where r.channel_id=f.channel_id and r.updated>=ts.min_updated) as relevant_reviews
       , (select sum(weight) from latest_review r where r.channel_id=f.channel_id and r.updated>=ts.min_updated and r.reviews_algo=0) as relevant_reviews_human
  from (
         -- flatten to row per tag & filter out stale reviews
         select channel_id
              , t.value::string as tag
              , r.email
              , r.reviews_algo
              , r.weight
              , updated
         from latest_review r
            , table (flatten(tags)) t
       ) f
         left join tag_stats ts on f.tag=ts.tag
)

   -- for each channel, calculate the final list of tags with a majority vote
   , tags_agg_all as (
  select channel_id
       , array_agg(tag) within group ( order by tag ) as tags
  from (
         select channel_id
              , tag
         from tags_flat
         group by channel_id, tag
         having sum(weight)>any_value(relevant_reviews)/2
       )
  group by channel_id
)

   -- as with tags_agg_all, but only humans. used for training other algo's without them influencing eachother
   , tags_agg_human as (
  select channel_id
       , array_agg(tag) within group ( order by tag ) as tags
  from (
         select channel_id
              , tag
         from tags_flat
         where reviews_algo=0
         group by channel_id, tag
         having sum(weight)>any_value(relevant_reviews_human)/2
       )
  group by channel_id
)

   -- group reviews by channel
   , r2 as (
  select channel_id
       , count(*) as reviews_all
       , sum(reviews_algo) as reviews_algo
       , array_agg(email) as reviewers
       , array_agg(object_construct(
      'email', email
    , 'lr', lr
    , 'main_channel_id', main_channel_id
    , 'notes', notes
    , 'relevance', relevance
    , 'tags', tags)) as reviews
       , decode(round(avg(lrnum)), -1, 'L', 0, 'C', 1, 'R') as lr
       , decode(round(avg(lrnum_human)), -1, 'L', 0, 'C', 1, 'R') as lr_human
       , avg(relevance) as relevance
       , avg(relevance_human) as relevance_human
  from latest_review r
  group by 1
)

   -- latest channel (don't use the channel table so it can depend on this table)
   , cl as (
  select v:ChannelId::string as channel_id
       , v:ChannelTitle::string as channel_title
  from channel_stage
    qualify row_number() over (partition by channel_id order by v:Updated::timestamp_ntz desc)=1
)

   , s as (
  select c.channel_title
       , coalesce(ta.tags, array_construct()) as tags
       , coalesce(th.tags, array_construct()) as tags_human
       , r2.*
  from r2
         left join cl c on r2.channel_id=c.channel_id
         left join tags_agg_all ta on r2.channel_id=ta.channel_id
         left join tags_agg_human th on r2.channel_id=th.channel_id
)
select *
from s